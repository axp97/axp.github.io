<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>this指针 &amp; 闭包 &amp; 作用域</title>
      <link href="2021/05/03/frontend/relearn/this-bi-bao-zuo-yong-yu/"/>
      <url>2021/05/03/frontend/relearn/this-bi-bao-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>深入理解 <code>this</code></li><li>理解作用域</li><li>理解闭包</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p><img src="/static/xmind/frontEnd/relearn/this.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程</title>
      <link href="2021/04/19/frontend/relearn/mian-xiang-dui-xiang-bian-cheng-yuan-xing-ji-yuan-xing-lian/"/>
      <url>2021/04/19/frontend/relearn/mian-xiang-dui-xiang-bian-cheng-yuan-xing-ji-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>清楚面向对象编程思想</li><li>深入原型及原型链： 对象间关系</li><li>手写实现 new 函数</li><li>深入继承：多种继承的实现</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><h3 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h3><p>实际是一种思想。当问题复杂或参与方较多建议使用，她你能简化问题，方便后期扩展和维护。</p><h3 id="2-原型及原型链"><a href="#2-原型及原型链" class="headerlink" title="2. 原型及原型链"></a>2. 原型及原型链</h3><p>原型链实际是对象间的关系：由 <strong>proto</strong> 和 prototype 连接的链条。</p><h4 id="2-1-手写实现-new-函数"><a href="#2-1-手写实现-new-函数" class="headerlink" title="2.1. 手写实现 new 函数"></a>2.1. 手写实现 new 函数</h4><p>在内存中开辟一段空间，添加原型，将 this 挂在这个对象上</p><p><strong>具体</strong></p><ol><li>用new Object() 的方式新建了一个对象 obj</li><li>取第一个参数，即传入的构造函数。此外因 shift 会修改原数组，所以 arguments 会被去除第一个参数</li><li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li><li>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</li><li>返回 obj</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token keyword">let</span> ret <span class="token operator">=</span> Constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> ret <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> ret <span class="token punctuation">:</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h3><p>父类拥有的方法和属性、静态方法等，子类也要拥有。</p><h4 id="3-1-原型链继承"><a href="#3-1-原型链继承" class="headerlink" title="3.1. 原型链继承"></a>3.1. 原型链继承</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Person 的实例同时包含实例属性方法和原型属性方法</span>Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 保证 student.constructor 类型正确</span>Student<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span><span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>缺点</strong></p><p>1.引用类型的属性被所有实例共享<br>2.在创建 ChildCon 的实例时，不能向 ParentCon 传参</p><h4 id="3-2-构造函数继承（经典继承）"><a href="#3-2-构造函数继承（经典继承）" class="headerlink" title="3.2. 构造函数继承（经典继承）"></a>3.2. 构造函数继承（经典继承）</h4><p>将父类的实例作为子类的原型</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name；<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 多参： Person.apply(this, Array.from(arguments).slice(1));</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>缺点</strong></p><ol><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li><li>函数是引用类型，父类的函数在子类的实例下不共享</li></ol><h4 id="3-3-组合继承"><a href="#3-3-组合继承" class="headerlink" title="3.3. 组合继承"></a>3.3. 组合继承</h4><p>原型式继承和构造函数继承的组合，兼具了二者的优点。<br>普通属性 使用 构造函数继承，函数 使用 原型链继承</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'music'</span><span class="token punctuation">,</span><span class="token string">'reading'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am a person'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Student<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span></code></pre><p><strong>缺点</strong></p><p>调用了两次父类的构造函数，造成了性能上的浪费</p><h4 id="3-4-原型式继承"><a href="#3-4-原型式继承" class="headerlink" title="3.4. 原型式继承"></a>3.4. 原型式继承</h4><p>实质：对参数对象的一个浅复制<br>ES5 Object.create 的模拟实现，传入的对象作为创建的对象的原型。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>缺点：同 原型链继承</strong></p><ol><li>父类的引用属性会被所有子类实例共享</li><li>子类构建实例时不能向父类传递参数</li></ol><h4 id="3-5-寄生式继承"><a href="#3-5-寄生式继承" class="headerlink" title="3.5. 寄生式继承"></a>3.5. 寄生式继承</h4><p>使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> createObj <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    clone<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> clone<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>缺点：同 借用构造函数</strong></p><ol><li>每次创建对象都会创建一遍方法</li></ol><h4 id="3-6-寄生组合式继承（基于组合继承）"><a href="#3-6-寄生组合式继承（基于组合继承）" class="headerlink" title="3.6. 寄生组合式继承（基于组合继承）"></a>3.6. 寄生组合式继承（基于组合继承）</h4><p>只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> Parent <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> Child <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 关键的三步</span><span class="token keyword">var</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>优点</strong></p><p>因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费</p><h4 id="3-7-ES6-Class-extends"><a href="#3-7-ES6-Class-extends" class="headerlink" title="3.7. ES6 Class extends"></a>3.7. ES6 Class extends</h4><p>寄生组合继承的语法糖，是ES5继承的语法糖<br>本质上，ES6 的类只是 ES5 的构造函数的一层包装</p><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><h3 id="1-类数组转为数组"><a href="#1-类数组转为数组" class="headerlink" title="1. 类数组转为数组"></a>1. 类数组转为数组</h3><ul><li>[…arguments].slice()</li><li>Array.prototype.slice.call(arguments)</li><li>Array.from</li><li>[].slice.call(arguments)</li></ul><h3 id="2-原型链神图"><a href="#2-原型链神图" class="headerlink" title="2. 原型链神图"></a>2. 原型链神图</h3><p><img src="/static/xmind/frontEnd/relearn/oop-chain.png" alt></p><h4 id="2-1-玩一玩-Function-proto-Function-prototype"><a href="#2-1-玩一玩-Function-proto-Function-prototype" class="headerlink" title="2.1. 玩一玩~ Function.proto === Function.prototype"></a>2.1. 玩一玩~ Function.<strong>proto</strong> === Function.prototype</h4><p><strong>1. Why yes？</strong></p><p>按照 JavaScript 中“实例”的定义，a 是 b 的实例即 a instanceof b 为 true，默认判断条件就是 b.prototype 在 a 的原型链上。</p><p>而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype，正符合此定义。</p><p><strong>2. Why no？</strong></p><p>Function 是 built-in 的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当你直接写一个函数时（如 function f() {} 或 x =&gt; x），也不存在调用 Function 构造器，只有在显式调用 Function 构造器时（如 new Function(‘x’, ‘return x’) ）才有。</p><p>把  Function.<strong>proto</strong> 指向 Function.prototype 是为了保证原型链的完整，让 Function 可以获取定义在 Object.prototype 上的方法。</p><p><img src="/static/xmind/frontEnd/relearn/oop.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探TypeScript</title>
      <link href="2021/04/12/frontend/relearn/chu-tan-typescript/"/>
      <url>2021/04/12/frontend/relearn/chu-tan-typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>熟悉 ts </li><li>面试题及实战</li><li>了解 ts 基本原理</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p><img src="/static/xmind/frontEnd/relearn/ts.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器详解</title>
      <link href="2021/04/11/frontend/relearn/liu-lan-qi-xiang-jie/"/>
      <url>2021/04/11/frontend/relearn/liu-lan-qi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>了解常⻅浏览器 JS 对象常⻅ API 及⽤法</li><li>深入浏览器事件模型：捕获与冒泡</li><li>封装函数：多浏览器兼容的绑定事件函数</li><li>理解 ajax 及 fetch API</li><li>封装一个 ajax 请求</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><h3 id="1-浏览器内置对象"><a href="#1-浏览器内置对象" class="headerlink" title="1. 浏览器内置对象"></a>1. 浏览器内置对象</h3><p><strong>浏览器对象模型</strong>（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。</p><p><strong>BOM</strong> 由多个对象组成，其中代表浏览器窗口的 Window 对象是 BOM 的顶层对象，其他对象都是该对象的子对象。</p><h3 id="2-浏览器事件模型"><a href="#2-浏览器事件模型" class="headerlink" title="2. 浏览器事件模型"></a>2. 浏览器事件模型</h3><p>浏览器事件模型中的过程主要分为三个阶段：捕获阶段、目标阶段、冒泡阶段。</p><p><img src="/static/xmind/frontEnd/relearn/browser-event.png" alt="事件模型图"></p><h5 id="2-1-封装多浏览器兼容的绑定事件函数"><a href="#2-1-封装多浏览器兼容的绑定事件函数" class="headerlink" title="2.1. 封装多浏览器兼容的绑定事件函数"></a>2.1. 封装多浏览器兼容的绑定事件函数</h5><h5 id="2-2-事件委托"><a href="#2-2-事件委托" class="headerlink" title="2.2. 事件委托"></a>2.2. 事件委托</h5><p><strong>问题</strong></p><p>页面为 ul + li 结构，点击每个 li alert 对应的索引</p><p><strong>思路</strong></p><p>利用冒泡，将 li 的点击事件委托给 ul 实现</p><p><strong>实现</strong></p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 3 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 4 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 5 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> 6 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 方式 1：事件委托给 ul</span>    <span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> target <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> liList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> index <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>liList<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`内容为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">.</span>innerHTML<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，索引为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 方式 2：给每个 li 绑定事件</span>    <span class="token comment" spellcheck="true">// const liList = document.getElementsByTagName("li");</span>    <span class="token comment" spellcheck="true">// for (let i = 0; i &lt; liList.length; i++) {</span>    <span class="token comment" spellcheck="true">//     liList[i].addEventListener('click', function (e) {</span>    <span class="token comment" spellcheck="true">//     alert(`内容为${e.target.innerHTML}, 索引为${i}`);</span>    <span class="token comment" spellcheck="true">//   })</span>    <span class="token comment" spellcheck="true">// }</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector">ul li </span><span class="token punctuation">{</span>      <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>      <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>      <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>      <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="3-浏览器请求相关"><a href="#3-浏览器请求相关" class="headerlink" title="3. 浏览器请求相关"></a>3. 浏览器请求相关</h3><h4 id="3-1-封装Ajax请求"><a href="#3-1-封装Ajax请求" class="headerlink" title="3.1. 封装Ajax请求"></a>3.1. 封装Ajax请求</h4><p><img src="/static/xmind/frontEnd/relearn/browser.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化详解</title>
      <link href="2021/04/05/frontend/relearn/js-mo-kuai-hua-xiang-jie/"/>
      <url>2021/04/05/frontend/relearn/js-mo-kuai-hua-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>首先我们明确一下：编程的本质是管理变量呀。为了更好的管理代码、组织及通信的模式而出现了模块化的技术方案。</p><p>本质上模块就是一种提供对外通信接口，进行代码切分/组合的管理方式。其呈现的方式因不同的模块化方案而不同，基本是以文件粒度区分。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><strong>为什么学</strong></p><ul><li>知古鉴今，单一职，关注分离</li><li>深入理解 JS 模块化</li></ul><p><strong>能学到什么</strong></p><ul><li>了解模块化概念</li><li>手写实现</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><h3 id="JS-模块化"><a href="#JS-模块化" class="headerlink" title="JS 模块化"></a>JS 模块化</h3><h4 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1. 发展历史"></a>1. 发展历史</h4><p><strong>1.1. 函数时代</strong></p><p>缺点：命名冲突、全局污染</p><p><strong>1.2. 命名空间</strong></p><p>优点：函数命个名，单一职<br>缺点：能访问还能改</p><p><strong>1.3. 闭包</strong></p><p>现代模块化的基石<br>特点：私有性、可往里塞东西；依赖注入<br>缺点：函数通信，window 上挂</p><p><strong>1.4. 接口方式</strong></p><p>不挂全局，写个函数 return 结果的形式<br>现在模块化机制的基本雏形</p><h4 id="2-类别"><a href="#2-类别" class="headerlink" title="2. 类别"></a>2. 类别</h4><h5 id="2-1-AMD"><a href="#2-1-AMD" class="headerlink" title="2.1 AMD"></a>2.1 AMD</h5><h5 id="2-2-CMD"><a href="#2-2-CMD" class="headerlink" title="2.2 CMD"></a>2.2 CMD</h5><h5 id="2-3-AMD"><a href="#2-3-AMD" class="headerlink" title="2.3 AMD"></a>2.3 AMD</h5><h5 id="2-4-ESM"><a href="#2-4-ESM" class="headerlink" title="2.4 ESM"></a>2.4 ESM</h5><h5 id="2-5-UMD"><a href="#2-5-UMD" class="headerlink" title="2.5 UMD"></a>2.5 UMD</h5><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><p>待更新…</p><p><img src="/static/xmind/frontEnd/relearn/modular.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise规范及应用</title>
      <link href="2021/04/04/frontend/relearn/promise-gui-fan-ji-ying-yong/"/>
      <url>2021/04/04/frontend/relearn/promise-gui-fan-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><strong>为什么学</strong></p><ul><li>Promise 重要性：async/await 语法的基础，JavaScript 中处理异步的标准形式。</li><li>深入理解 Promises 运行机制</li></ul><p><strong>能学到什么</strong></p><ul><li>熟悉 Promise A+ 规范</li><li>实现一个 Promise</li><li>简介 Generator 和 Async</li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><h3 id="PromiseA-规范"><a href="#PromiseA-规范" class="headerlink" title="PromiseA+规范"></a>PromiseA+规范</h3><h4 id="1-了解术语"><a href="#1-了解术语" class="headerlink" title="1. 了解术语"></a>1. 了解术语</h4><ul><li><code>promise</code> 是一个包含 then 方法的对象或函数，该方法符合规范指定的行为。</li><li><code>thenable</code> 是一个包含 then 方法和对象或者函数。</li><li><code>value</code> 就是任意合法 JS 值。</li><li><code>exception</code> 就是 throw 语句抛出的值。</li><li><code>reason</code> 是一个指示 promise 为什么被 rejected 的值。</li></ul><h4 id="2-Promise-状态"><a href="#2-Promise-状态" class="headerlink" title="2. Promise 状态"></a>2. Promise 状态</h4><ul><li><p><strong>pending</strong><br>初始状态，可改变<br>在 resolve 和 reject 前都处于这个状态</p><pre><code>  --&gt; resolve(value) --&gt; fulfilled  --&gt; reject(reason) --&gt; rejected</code></pre></li><li><p><strong>fulfilled</strong><br>一次性特征：最终态，不可变<br>必须拥有一个 value 值</p></li><li><p><strong>rejected</strong><br>最终态，不可变<br>必须拥有一个 reason</p></li></ul><h4 id="3-Then-方法"><a href="#3-Then-方法" class="headerlink" title="3. Then 方法"></a>3. Then 方法</h4><p>promise 必须有 then 方法，接受 <code>onFulfilled</code> 和 <code>onRejected</code> 参数。</p><h5 id="3-1-参数规范"><a href="#3-1-参数规范" class="headerlink" title="3.1. 参数规范"></a>3.1. 参数规范</h5><ul><li>函数：必须最多执行一次</li><li>非函数：忽略，返回默认值/函数</li></ul><h5 id="3-2-参数特性"><a href="#3-2-参数特性" class="headerlink" title="3.2. 参数特性"></a>3.2. 参数特性</h5><p>微任务阶段执行，执行时机：</p><ul><li>promise  –&gt; fulfilled/rejected 时，调用 onFulFilled(value) / onRejected(reson)</li><li>在 promise 变成 fulfilled/rejected 之前，不应该调用 onFulfilled/onRejected</li><li>只能调用一次</li></ul><h4 id="4-then-方法可以调用多次"><a href="#4-then-方法可以调用多次" class="headerlink" title="4. then 方法可以调用多次"></a>4. then 方法可以调用多次</h4><p>执行时机：</p><p>promise –&gt; fulfilled / rejected 后，按照注册的顺序执行</p><h4 id="5-返回值：promise"><a href="#5-返回值：promise" class="headerlink" title="5. 返回值：promise"></a>5. 返回值：promise</h4><p>若返回非函数：</p><p>promise2 以 promise1 的 value/reson 触发 fulfilled</p><p>返回函数：</p><p>onFulfilled / onRejected 执行，过程中抛出e，promise2 需要 reject</p><p>结果为 x，调用 <code>resolvePromise</code></p><h4 id="6-resolvePromise-promise2-x-resolve-reject"><a href="#6-resolvePromise-promise2-x-resolve-reject" class="headerlink" title="6. resolvePromise(promise2, x, resolve, reject)"></a>6. resolvePromise(promise2, x, resolve, reject)</h4><h5 id="6-1-参数"><a href="#6-1-参数" class="headerlink" title="6.1 参数"></a>6.1 参数</h5><ul><li>promise2：当前第一个 promise 的返回</li><li>x：onFulfilled/onRejected 执行结果</li></ul><h5 id="6-2-规范"><a href="#6-2-规范" class="headerlink" title="6.2 规范"></a>6.2 规范</h5><p><strong>1. 避免死循环</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span>｛    reject typeError｝</code></pre><p><strong>2. type x</strong></p><ul><li>promise，取决于 x 的状态<br>pending：promise 必须在 pending 状态，直到 x 的状态变更<br>fulfilled：value -&gt; fulfilled<br>rejected：reason -&gt; rejected</li></ul><ul><li>Object || Function<br><code>const then = x.then</code></li></ul><p>如果报错，reject reson</p><ul><li>非函数：resolve(x)</li><li>函数：then.call(x, resolvePromiseFn, rejectPromiseFn)</li></ul><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>ES6 引入的一种新的遍历机制，也是一种特殊对象，它具有一些专门为迭代过程设计的专有接口。</p><p>可调用 next() 方法，返回一个当前结果对象。</p><p><strong>next()方法：</strong></p><p>value：当前属性的值<br>done：用于判断是否遍历结束，当没有更多可返回的数据时，返回true</p><h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格.</p><h3 id="Async-和-Await"><a href="#Async-和-Await" class="headerlink" title="Async 和 Await"></a>Async 和 Await</h3><p>实际：Promise 语法糖，同步的形式写</p><p><img src="/static/xmind/frontEnd/relearn/promise.png" alt="xmind总结"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue详细上手指北</title>
      <link href="2020/06/20/frontend/vue/vue-xiang-xi-shang-shou-zhi-bei/"/>
      <url>2020/06/20/frontend/vue/vue-xiang-xi-shang-shou-zhi-bei/</url>
      
        <content type="html"><![CDATA[<p>这是篇教程，跟着我的节奏来，学完后可以独立上手开发 Vue 项目！</p><h2 id="01-快速搭建项目"><a href="#01-快速搭建项目" class="headerlink" title="01 快速搭建项目"></a>01 快速搭建项目</h2><p>本节目的：用 Vue-cli 脚手架搭建一个 Vue 项目。<br><a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">戳官网教程</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="Vue-是什么"><a href="#Vue-是什么" class="headerlink" title="Vue 是什么"></a>Vue 是什么</h4><p>一套用于构建用户界面的前端 JS 框架。<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">戳官网详细介绍</a></p><h4 id="为什么用-Vue"><a href="#为什么用-Vue" class="headerlink" title="为什么用 Vue"></a>为什么用 Vue</h4><p>流行：github 上 star 最多的前端框架，招聘大多要求。<br>学习：上手简单（数据驱动）<br>性能：组件化，性能好，运行速度快</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>Q：Vue 开发跟传统 Web 开发相比的优势？</strong><br>A：传统开发需操作 dom 元素，Vue 只关心图层，用数据驱动视图。减少额代码工作量，能更快地开发迭代项目。</p><hr><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><h4 id="1、环境配置：node-js"><a href="#1、环境配置：node-js" class="headerlink" title="1、环境配置：node.js"></a>1、环境配置：node.js</h4><ul><li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">戳官网链接下载</a></li><li>下载安装成功后可查看版本<ol><li>打开命令行（Win+R，键入 cmd）输入     node -v</li><li>查看 npm 版本（node 自带安装了 npm）    npm -v</li><li>无报错，即显示了 node 版本即成功</li></ol></li></ul><h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><p><strong>Q：为什么用 node.js？</strong><br>A：node.js 在这里提供 npm 安装，为了方便模块管理。也可以 Web 页面中直接使用。</p><h4 id="2、安装-vue-cli-包"><a href="#2、安装-vue-cli-包" class="headerlink" title="2、安装 vue/cli 包"></a>2、安装 vue/cli 包</h4><ul><li>命令行输入：<code>npm install -g @vue/cli</code></li><li>安装后，命令行查看版本，输入：<code>vue --version</code></li></ul><h4 id="3、创建项目"><a href="#3、创建项目" class="headerlink" title="3、创建项目"></a>3、创建项目</h4><p>利用脚手架创建一个默认配置的名称为 first_vue 的项目</p><ul><li>到指定文件夹打开命令行</li><li>命令行输入：<code>vue create first_vue</code><br><img src="/static/vue/tutorial/chapter1_1.png" alt></li><li>完成后显示<br><img src="/static/vue/tutorial/chapter1_2.png" alt></li><li>命令行进入项目目录和运行项目；浏览器打开<br><img src="/static/vue/tutorial/chapter1_3.png" alt><br><img src="/static/vue/tutorial/chapter1_4.png" alt></li></ul><h2 id="02-下一节"><a href="#02-下一节" class="headerlink" title="02 下一节"></a>02 下一节</h2><p>下一节还没写好，客官稍安勿躁~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter手摸手趟坑</title>
      <link href="2020/06/14/frontend/flutter/flutter-shou-mo-shou-tang-keng/"/>
      <url>2020/06/14/frontend/flutter/flutter-shou-mo-shou-tang-keng/</url>
      
        <content type="html"><![CDATA[<p>前段时间由于公司需要，赶鸭子上架，用 Flutter 做了个简单 app，记录下实际中遇到的小坑~</p><h4 id="1-无法将”Unblock-File”项识别为-cndlet、-函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。"><a href="#1-无法将”Unblock-File”项识别为-cndlet、-函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。" class="headerlink" title="1. 无法将”Unblock-File”项识别为 cndlet、 函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。"></a>1. 无法将”Unblock-File”项识别为 cndlet、 函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。</h4><p><span style="color: green;">解决：到 windows 官网更新最新版的 powershell 5.0 版本，安装后重启并再次运行 <code>flutter doctor</code> </span></p><p>1.1、找到 PowerShell 程序，进入命令行窗口；<br>win+R 输入<code>PowerShell</code>；在命令行窗口中输入命令：<code>$PSVersionTable.PSVersion</code><br><img src="en-resource://database/4694:1" alt="4815c08233054a3a9e10834042866e24.png"><br>（实际版本会低于 5.0 才会报错）</p><p>1.2、点击下载 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=54616" target="_blank" rel="noopener">Windows Management Framework 5.1</a><br><img src="en-resource://database/4695:1" alt="5b04a066975eec1656144803c8e21050.png"><br><strong>安装程序遇到错误：0x80240037</strong></p><p>2、把 Win7AndW2K8R2-KB3191566-x64.msu 的后缀名 <code>.msu</code> 改成 <code>.cab</code> 并解压到新文件夹中 cab（名字任起，我把它移到了 E 盘了）<br><img src="en-resource://database/4696:1" alt="12f99cb4a25c46d589616bbf69ac0e88.png"></p><p>3、打开 cmd，以管理员身份运行)，输入：</p><p><code>dism /online /add-package /packagepath:&quot;文件名.cab的完整路径&quot;</code></p><p>注：解压出来可能会有多个.cab，注意输入对应好的文件名.cab（前面下载的名字中是：KB2819745）安装好后，会提示是否立即重新启动：y（重新启动）</p><p><img src="en-resource://database/4697:1" alt="c937cad7c98c9e04edca6e1b07c9bac0.png"></p><p>4、cmd 输入 / 双击 flutter_console.bat 后输入 /打开 PowerShell 输入： <code>flutter doctor</code></p><p><code>WSUSSCAN.cab 是什么？cab 是什么文件？*.cab是微软制定的压缩包文件，常用于软件的安装程序。WSUSSCAN.cab 应该是更新补丁检测文件 补丁的扫描、下载和安装 在安装服务器的机器上同时运行着补丁下载器， 它会自动下载并更新补丁检测文件(wsusscan.cab)</code></p><h4 id="2-flutter-sdk-降级、回退、升级降级到指定的版本方法"><a href="#2-flutter-sdk-降级、回退、升级降级到指定的版本方法" class="headerlink" title="2. flutter sdk 降级、回退、升级降级到指定的版本方法"></a>2. flutter sdk 降级、回退、升级降级到指定的版本方法</h4><p><span style="color: green;">解决：<code>git reset --hard &lt;commit版本号&gt;</code></span></p><ul><li>进入<a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter Git 源码</a>，release &gt; tags &gt; 拿到 commit 版本</li></ul><p><strong>切换 flutter sdk</strong><br>flutter 安装目录中执行：<code>git checkout v0.1.9</code>****<br>然后运行：<code>flutter doctor</code></p><h4 id="3-Waiting-for-another-flutter-command-to-release-the-startup-lock…"><a href="#3-Waiting-for-another-flutter-command-to-release-the-startup-lock…" class="headerlink" title="3. Waiting for another flutter command to release the startup lock…"></a>3. Waiting for another flutter command to release the startup lock…</h4><p><span style="color: green;">解决：删除 lockfile 文件</span></p><ul><li>打开 flutter/bin/cache/lockfile，删除</li><li>或者用命令：<code>rm ./flutter/bin/cache/lockfile</code></li></ul><h4 id="4-Flutter-android-GradleException-显示红色报错解决办法"><a href="#4-Flutter-android-GradleException-显示红色报错解决办法" class="headerlink" title="4. Flutter android GradleException 显示红色报错解决办法"></a>4. Flutter android GradleException 显示红色报错解决办法</h4><p><span style="color: green;">解决：</span></p><pre><code>throw new GradleException(...)</code></pre><p>替换</p><pre><code>throw new Exception(...)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack浅学习</title>
      <link href="2020/06/07/frontend/tool/webpack-qian-xue-xi/"/>
      <url>2020/06/07/frontend/tool/webpack-qian-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>几乎每个项目用到 <code>Webpack</code>，花时间系统地学习了下。<br>第一遍学基础，整理了如下思维导图，留坑待更新。</p><p><img src="/static/xmind/200607.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《最好的告别》</title>
      <link href="2020/05/24/book/other/zui-hao-de-gao-bie/"/>
      <url>2020/05/24/book/other/zui-hao-de-gao-bie/</url>
      
        <content type="html"><![CDATA[<h3 id="这本书整体谈了什么？"><a href="#这本书整体谈了什么？" class="headerlink" title="这本书整体谈了什么？"></a>这本书整体谈了什么？</h3><p>全书穿插事例，探究了衰老与死亡以及如何优雅跨越生命终点。附读书笔记思维导图。</p><p><a href="https://book.douban.com/subject/26576861/" target="_blank" rel="noopener">豆瓣传送门</a></p><h3 id="细部说了什么？"><a href="#细部说了什么？" class="headerlink" title="细部说了什么？"></a>细部说了什么？</h3><ol><li>医学教我们认识衰老与死亡</li><li>述了美国的临终医疗、护理和养老三大话题</li><li>人生因为自主而有价值</li><li>该为死亡做些什么准备</li></ol><h3 id="它与我关系是什么？"><a href="#它与我关系是什么？" class="headerlink" title="它与我关系是什么？"></a>它与我关系是什么？</h3><p>这是本温柔而又充满力量的书。怀着对衰老与死亡的迷茫和恐惧，看完后，我坦然。<br>思考死亡是为了活的更好，推荐此书。</p><p><img src="/static/xmind/200524.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 社会科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《如何阅读一本书》</title>
      <link href="2020/05/02/book/other/ru-he-yue-du-yi-ben-shu/"/>
      <url>2020/05/02/book/other/ru-he-yue-du-yi-ben-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="这本书整体谈了什么？"><a href="#这本书整体谈了什么？" class="headerlink" title="这本书整体谈了什么？"></a>这本书整体谈了什么？</h3><p>一本实用型的书，核心教导了读者如何择书并主动阅读，讲述阅读的四种层次，以及每种层次所需要的、截然不同的阅读方法。部分叙述冗长重复，可选择性略读。附读书笔记思维导图。<br><a href="https://book.douban.com/subject/1013208/" target="_blank" rel="noopener">豆瓣传送门</a></p><h3 id="细部说了什么？"><a href="#细部说了什么？" class="headerlink" title="细部说了什么？"></a>细部说了什么？</h3><p>做一个有自我要求的读者，养成主动阅读的习惯。</p><ol><li>读前四问，读后解决问题</li><li>速读抓出重点，认识其值不值得再读</li><li>解构阅读以做笔记的形式</li><li>尊重并理性评断一本书</li></ol><h3 id="这本书写的有道理吗？"><a href="#这本书写的有道理吗？" class="headerlink" title="这本书写的有道理吗？"></a>这本书写的有道理吗？</h3><p>有一定的道理，给了一套系统的阅读技巧。但是作者的思想有点片面，阅读方式对文学作品也有一定的局限性。</p><h3 id="它与我关系是什么？"><a href="#它与我关系是什么？" class="headerlink" title="它与我关系是什么？"></a>它与我关系是什么？</h3><p>以前自己更多注重阅读感受，现在明白理性阅读也很重要。</p><p><img src="/static/xmind/200502.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 实用型书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识淘客</title>
      <link href="2020/04/25/life/parttime/chu-shi-tao-ke/"/>
      <url>2020/04/25/life/parttime/chu-shi-tao-ke/</url>
      
        <content type="html"><![CDATA[<p>接触了解淘客后的第二年，觉得自己也可以试试~</p><h2 id="领劵返利教程"><a href="#领劵返利教程" class="headerlink" title="领劵返利教程"></a>领劵返利教程</h2><h3 id="图片教程"><a href="#图片教程" class="headerlink" title="图片教程"></a>图片教程</h3><p><img src="/static/life/tutorialPic.png" alt></p><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><iframe height="498" width="100%" src="/static/life/tutorialVideo.mp4"></iframe><h2 id="联系我吧"><a href="#联系我吧" class="headerlink" title="联系我吧"></a>联系我吧</h2><p>感兴趣的话联系我吧~</p><ul><li><strong>微信</strong><br>shadow-0520</li><li><strong>QQ</strong><br><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=643382875" class="tooltipped" data-tooltip="QQ联系我: 643382875" data-position="top" data-delay="50" target="_blank" rel="noopener">643382875</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼职 </tag>
            
            <tag> 淘客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js之组件间通信</title>
      <link href="2019/09/29/frontend/vue/vue-zhi-zu-jian-tong-xun/"/>
      <url>2019/09/29/frontend/vue/vue-zhi-zu-jian-tong-xun/</url>
      
        <content type="html"><![CDATA[<p><code>Vue</code> 组件间的通信是 <code>Vue</code> 开发中很基础也十分重要的部分，写一个 Vue 工程，实际是在写一个个的组件。下面根据场景介绍组件间常用的几种通信方式~ 文章只贴出重点代码，详细代码戳demo链接~ 戳戳戳~</p><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><h3 id="props-和-emits"><a href="#props-和-emits" class="headerlink" title="props 和 $emits"></a>props 和 $emits</h3><p><strong>场景1：父组件给子组件取名字（子组件的‘name’为父组件传递）</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Dad<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subcomponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        I am a {{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>props: ['name']</code></pre><p><code>props</code> 可以是数组或对象，为对象时允许配置高级选项，如类型检测、自定义验证和设置默认值。<br><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">prop更详细信息戳这里</a></p><hr><p><strong>场景2：子组件召唤父组吃饭啦（子组件的通过$emit传递事件给父组件）</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Dad<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Son</span> <span class="token attr-name">@calldad</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>receivedMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>calldad<span class="token punctuation">'</span>, <span class="token punctuation">'</span>Dad,开饭拉！<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>callDad<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><a href="https://codepen.io/axp97/pen/ZEzqJPa" target="_blank" rel="noopener">戳demo看效果</a></p><blockquote><p><strong>总结</strong>：父组件通过 <code>prop</code> 给子组件下发数据，子组件通过 <code>$emit</code> 触发事件给父组件发送消息，即 <code>prop</code> 向下传递，事件向上传递。</p></blockquote><h2 id="三层组件通信"><a href="#三层组件通信" class="headerlink" title="三层组件通信"></a>三层组件通信</h2><h3 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a>$attrs 和 $listeners</h3><p><strong>场景1：爷爷组件给孙组件礼物（孙组件的‘gift’为爷爷组件传递）</strong></p><p>这里孙组件要获取搭配爷爷组件传递过来的值，可以用 <strong>props逐级传递</strong> ，也可以用Vue2.4.0新增的 <code>$attrs</code> 属性。简单讲的：<code>$attrs</code> 包含所有的父作用域的绑定（除了prop传递的属性、class 和 style ）。在这个场景里，给孙组件上绑定<code>$attrs</code>，获得其父的绑定，可以简便实现。<br><a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener">$attrs官方介绍戳这里</a></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Dad<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Son</span> <span class="token attr-name">:gift</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gift<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>data() {    return {      gift: "A lot of candy"    };},</code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Grandson</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$attrs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Grandson</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Grandson<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Gifts from the Grandpa component: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>{{gift}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>props: ["gift"]</code></pre><p><strong>场景2：孙组件召唤爷爷组件吃饭啦（孙组件触发爷爷组件事件）</strong></p><p>这里孙组件要触发爷爷组件事件，可以用 <strong>$emit逐级触发</strong> ，也可以用Vue2.4.0新增的 <code>$listeners</code> 属性。<code>$listeners</code> 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。<br><a href="https://cn.vuejs.org/v2/api/#vm-listeners" target="_blank" rel="noopener">$listeners官方介绍戳这里</a></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Dad<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Son</span> <span class="token attr-name">:gift</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gift<span class="token punctuation">"</span></span> <span class="token attr-name">@callgrandpa</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>callgrandpa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>methods: {        callgrandpa(msg) {                alert(msg);        }  }</code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Grandson</span> <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$listeners<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Grandson</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Grandson<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>callGrandpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>methods: {        onClick() {                this.$emit("callgrandpa", "Grandpa, dinner pull!");        }}</code></pre><p><a href="https://codepen.io/axp97/pen/RwbObQY" target="_blank" rel="noopener">戳demo看效果</a></p><blockquote><p><strong>总结</strong>：三级组件通信时，当爷爷组件需要与孙组件通信，使用<code>$attrs</code>和<code>$listeners</code>更简洁。</p></blockquote><h2 id="多级组件通信"><a href="#多级组件通信" class="headerlink" title="多级组件通信"></a>多级组件通信</h2><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p><code>EventBus</code> 通过新建一个 <code>Vue</code> 事件 <code>bus</code> 对象，然后通过 <code>bus.$emit</code> 触发事件，<code>bus.$on</code> 监听触发的事件。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// event-bus.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">export</span> <span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// send messages</span>EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span>channel<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token function">callback</span><span class="token punctuation">(</span>payload1<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// listen to receive messages</span>EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>channel<span class="token punctuation">:</span> string<span class="token punctuation">,</span> <span class="token function">callback</span><span class="token punctuation">(</span>payload1<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>当我们需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。<br><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">戳Vuex官网链接</a></p><blockquote><p><strong>总结</strong>：EventBus 适用于小型简单项目，中大型项目用Vuex管理，当项目过于庞大, 可将 store 分割成模块。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
